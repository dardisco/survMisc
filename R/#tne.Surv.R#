##' tne
##' @title Time, No. at risk, No. events
##' @description For a \code{Surv} object, gives
##' time, no. at risk and no. events.
##' \cr \cr
##' For a \code{survfit} object with one predictor
##' describing right censored data, gives time, no. at risk
##' and no. events.
##' \cr
##' Also per-predictor estimates of no. at risk,
##' no. expected and no. events - no. expected.
##' \cr \cr
##' No. events expected (per predictor) is given by:
##' \deqn{\frac{e_i(n[p]_i)}{n_i}}{
##'  e(i)n[p](i) / n(i)}
##' where \eqn{n[p]_i} is the no. at risk for the predictor.
##' @param x A object of class \code{Surv} or \code{survfit}
##' @param ... Additional arguments, e.g.
##' \cr onlyEvents (For \code{Surv} object): if \code{TRUE}
##' shows only times at which at least one event occurred.
##' \cr
##' Otherwise shows \emph{all} times recorded (including those censored).
##' @return For a \code{Surv} object: A data frame with columns:
##' \item{t}{time}
##' \item{n}{no. at risk}
##' \item{e}{no. events}
##' \cr \cr
##' For a \code{survfit} object:  A data frame with columns:
##'  \item{t}{time}
##'  \item{n}{no. at risk (total)}
##'  \item{e}{no. events (total)}
##'  \item{p}{predictor}
##'  \item{np}{no. at risk (by predictor)}
##'  \item{Ep}{no. events expected (by predictor)}
##'  \item{e_Ep}{no. events minus no. events expected}
##' @examples
##' ### Surv object
##' df0 <- data.frame(t=c(1,1,2,3,5,8,13,21),
##'                   e=rep(c(0,1),4))
##' s1 <- Surv(df0$t,df0$e,type="right")
##' tne(s1)
##' tne(s1, onlyEvents=FALSE)
##' ### survfit object
##' data(kidney, package="KMsurv")
##' s <- survfit(Surv(time=time, event=delta) ~ type, data=kidney)
##' tne(s)
##' s <- survfit(Surv(time=time, event=delta) ~ 1, data=kidney)
##' tne(s)
##'
##' @rdname tne
##' @export tne
##'
tne <- function(x, ...){
    UseMethod("tne")
    }
##' @rdname tne
##' @method tne Surv
##' @S3method tne Surv
##'
tne.Surv <- function(x, ...){
    if(!class(x)=="Surv") stop
    "Only applies to class 'Surv'"
    if(!attr(x, which="type")=="right") warning
    "Only applies to right censored data"
### no. subjects leaving study in each time period
    r1 <- as.matrix(stats::aggregate(x[,"time"],
                                     by=list(x[,"time"]),
                                     FUN=length))
### no. events in each time period
    r2 <- as.matrix(stats::aggregate(x[,"status"],
                                     by=list(x[,"time"]),
                                     FUN=sum))
### join by time
    m1 <- merge(r1,r2,by=1)
    nr1 <- nrow(x)
### make no. at risk
    m1$n <- if(nrow(m1)==1){
        1} else {
            c(nrow(x),nrow(x)-(cumsum(m1[1:(nrow(m1)-1),2])))
        }
### reorder
    m1 <- m1[,c(1,4,3)]
    colnames(m1) <- c("t","n","e")
### (optional) show only times where events occurred
    onlyEvents <-TRUE
### get ellipsis
    el1 <- list(...)
    if ("onlyEvents" %in% names(el1)){
        onlyEvents <- el1$onlyEvents
    }
    if (onlyEvents) m1 <- m1[!m1[,3]==0, ]
    return(m1)
}
###
###----------------------------------------
###
##' @rdname tne
##' @method tne survfit
##' @S3method tne survfit
tne.survfit <- function(x, ...){
    if (!class(x)=="survfit") stop("Only applies to object of class 'survfit'")
    if (length(eval(x$call[[2]])[[3]])>1) stop("Only applies to survfit formulas with one predictor")
### get location to evaluate variables (environment or data frame)
    if (is.null(x$call$data)){
        loc1 <- environment(eval(parse(text=as.character(x$call[2]))))
    } else {
        loc1 <- eval(x$call$data)
    }
### length of data frame (no. rows)
    l1 <- length(get(ls(loc1),loc1))
### hold predictor, time,  event, no. at risk (total)
### no. at risk (per predictor), no. Expected events (per predictor)
### no. events - no. Expected events (per predictor)
    df2 <- data.frame(matrix(0,nrow=l1,ncol=7))
    colnames(df2) <- c("t","n","e","p","np","Ep","e_Ep")
### get names of time, event and predictor...
### for name of time:
### get formula: eval(x$call[[2]]),
### then get LHS (Surv object): eval(x$call[[2]])[2]
### then remove trailing (): eval(x$call[[2]])[2][[1]]
### then get time variable
    t1 <- as.character(eval(x$call[[2]])[2][[1]][2])
    df2$t <- get(t1,loc1)
    e1 <- as.character(eval(x$call[[2]])[2][[1]][3])
    df2$e <- with(loc1, get(e1))
### for predictor:
### get RHS of formula: eval(x$call[[2]])[3]
### then remove trailing (): eval(x$call[[2]])[2][[1]]
    p1 <-  as.character(eval(x$call[[2]])[3][[1]])
### if one predictor (intercept-only) model:
    if (p1==1){
        df2$p <- rep(1,l1)
        } else {
            df2$p <-  with(loc1, get(p1))
            }
    df2 <- df2[order(df2$t, decreasing=FALSE), ]
    rownames(df2) <- NULL
### make no. at risk (total)
    df2[1,"n"] <- nrow(df2)
    df2[2:nrow(df2),"n"] <- nrow(df2)-cumsum(df2[,"e"][-nrow(df2)])
### make no. at risk (per predictor)
    p1 <- sort(unique(df2$p))
    for (i in 1:length(p1)) {
### total no. at risk
        s1 <- sum(df2$p==p1[i])
        df2[which(df2$p==p1[i]),"np"] <- seq(s1,1)
    }
### make no. expected events (per predictor)
    df2[,"Ep"] <- (df2[,"e"]*df2[,"np"]) / df2[,"n"]
### make events - expected
    df2[,"e_Ep"] <- df2[,"e"]-df2[,"Ep"]
    return(df2)
}
